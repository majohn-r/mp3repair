package main

import (
	"encoding/json"
	"fmt"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/goyek/goyek/v2"
	"github.com/josephspurrier/goversioninfo"
	tools_build "github.com/majohn-r/tools-build"
	"github.com/spf13/afero"
	"gopkg.in/yaml.v3"
)

const (
	coverageFile  = "coverage.out"
	buildDataFile = "buildData.yaml"
	// files generated by the build process
	versionInfoFile = "versionInfo.json"
	resourceFile    = "resource.syso"
)

var (
	fileSystem = afero.NewOsFs()
	pD         *productData
	build      = goyek.Define(goyek.Task{
		Name:  "build",
		Usage: "build the executable",
		Action: func(a *goyek.A) {
			buildExecutable(a)
		},
	})

	clean = goyek.Define(goyek.Task{
		Name:  "clean",
		Usage: "delete build products",
		Action: func(a *goyek.A) {
			fmt.Println("deleting build products")
			loadProductData()
			files := []string{
				versionInfoFile,
				resourceFile,
				coverageFile,
				pD.executable,
			}
			tools_build.Clean(files)
		},
	})

	_ = goyek.Define(goyek.Task{
		Name:  "coverage",
		Usage: "run unit tests and produce a coverage report",
		Action: func(a *goyek.A) {
			tools_build.GenerateCoverageReport(a, coverageFile)
		},
	})

	_ = goyek.Define(goyek.Task{
		Name:  "doc",
		Usage: "generate documentation",
		Action: func(a *goyek.A) {
			tools_build.GenerateDocumentation(a, []string{"build"})
		},
	})

	format = goyek.Define(goyek.Task{
		Name:  "format",
		Usage: "clean up source code formatting",
		Action: func(a *goyek.A) {
			tools_build.Format(a)
		},
	})

	lint = goyek.Define(goyek.Task{
		Name:  "lint",
		Usage: "run the linter on source code",
		Action: func(a *goyek.A) {
			tools_build.Lint(a)
		},
	})

	nilaway = goyek.Define(goyek.Task{
		Name:  "nilaway",
		Usage: "run nilaway on source code",
		Action: func(a *goyek.A) {
			tools_build.NilAway(a)
		},
	})

	updateDependencies = goyek.Define(goyek.Task{
		Name:  "updateDependencies",
		Usage: "update dependencies",
		Action: func(a *goyek.A) {
			tools_build.UpdateDependencies(a)
		},
	})

	vulnCheck = goyek.Define(goyek.Task{
		Name:  "vulnCheck",
		Usage: "run vulnerability check on source code",
		Action: func(a *goyek.A) {
			tools_build.VulnerabilityCheck(a)
		},
	})

	_ = goyek.Define(goyek.Task{
		Name:  "preCommit",
		Usage: "run all pre-commit tasks",
		Deps: goyek.Deps{
			clean,
			updateDependencies,
			lint,
			nilaway,
			format,
			vulnCheck,
			tests,
			build,
		},
	})

	tests = goyek.Define(goyek.Task{
		Name:  "tests",
		Usage: "run unit tests",
		Action: func(a *goyek.A) {
			tools_build.UnitTests(a)
		},
	})
)

type Config struct {
	// special functions:
	//   application: the application name
	//   timestamp:   treat as Flag, but the associated value is generated at runtime
	Function string
	// flag name
	Flag string
	// value to use
	Value string
	// application-specific fields
	Description string
	Name        string
}

func buildExecutable(a *goyek.A) {
	loadProductData()
	// logged output shows up when running verbose (-v) or on error
	a.Logf("configuration: %#v", pD)
	pD.generateVersionInfo()
	if tools_build.Generate(a) {
		fmt.Println("building executable")
		tools_build.RunCommand(a, fmt.Sprintf("go build -ldflags %q -o %s .", strings.Join(pD.flags, " "), pD.executable))
	}
}

type productData struct {
	majorLevel      int
	minorLevel      int
	patchLevel      int
	semanticVersion string
	flags           []string
	description     string
	name            string
	executable      string
	firstYear       int
}

func (pD *productData) copyright() string {
	currentYear := time.Now().Year()
	switch {
	case currentYear == pD.firstYear:
		return fmt.Sprintf("Copyright © %d Marc Johnson", currentYear)
	default:
		return fmt.Sprintf("Copyright © %d-%d Marc Johnson", pD.firstYear, currentYear)
	}
}

func (pD *productData) generateVersionInfo() {
	data := goversioninfo.VersionInfo{}
	data.FixedFileInfo.FileVersion.Major = pD.majorLevel
	data.FixedFileInfo.FileVersion.Minor = pD.minorLevel
	data.FixedFileInfo.FileVersion.Patch = pD.patchLevel
	data.FixedFileInfo.ProductVersion.Major = pD.majorLevel
	data.FixedFileInfo.ProductVersion.Minor = pD.minorLevel
	data.FixedFileInfo.ProductVersion.Patch = pD.patchLevel
	data.FixedFileInfo.FileFlagsMask = "3f"
	data.FixedFileInfo.FileOS = "040004"
	data.FixedFileInfo.FileType = "01"
	data.StringFileInfo.FileDescription = pD.description
	data.StringFileInfo.FileVersion = pD.semanticVersion
	data.StringFileInfo.LegalCopyright = pD.copyright()
	data.StringFileInfo.ProductName = pD.name
	data.StringFileInfo.ProductVersion = pD.semanticVersion
	data.VarFileInfo.Translation.LangID = goversioninfo.LngUSEnglish
	data.VarFileInfo.Translation.CharsetID = goversioninfo.CsUnicode
	b, _ := json.Marshal(data)
	fullPath := filepath.Join(tools_build.WorkingDir(), versionInfoFile)
	if fileErr := afero.WriteFile(fileSystem, fullPath, b, 0o644); fileErr != nil {
		fmt.Printf("error writing %q! %v\n", versionInfoFile, fileErr)
	}
}

func loadProductData() {
	if pD == nil {
		rawPD := &productData{}
		rawYaml, _ := afero.ReadFile(fileSystem, buildDataFile)
		var data []Config
		_ = yaml.Unmarshal(rawYaml, &data)
		for _, value := range data {
			switch value.Function {
			case "application":
				rawPD.executable = value.Value
				rawPD.name = value.Name
				rawPD.description = value.Description
			case "firstYear":
				if i, err := strconv.Atoi(value.Value); err == nil {
					rawPD.firstYear = i
				}
			case "timestamp":
				rawPD.flags = append(rawPD.flags, fmt.Sprintf("-X %s=%s", value.Flag, time.Now().Format(time.RFC3339)))
			default:
				rawPD.flags = append(rawPD.flags, fmt.Sprintf("-X %s=%s", value.Flag, value.Value))
				switch value.Flag {
				case "main.version":
					var major int
					var minor int
					var patch int
					if count, err := fmt.Sscanf(value.Value, "%d.%d.%d", &major, &minor, &patch); count == 3 && err == nil {
						rawPD.majorLevel = major
						rawPD.minorLevel = minor
						rawPD.patchLevel = patch
						rawPD.semanticVersion = fmt.Sprintf("v%s", value.Value)
					}
				}
			}
		}
		sort.Strings(rawPD.flags)
		pD = rawPD
	}
}
